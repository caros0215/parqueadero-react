{"ast":null,"code":"// src/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred = class {\n  promise;\n  resolve;\n  reject;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n\n};\n\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, {\n        stream: true\n      });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n\n  });\n} // src/flatten.ts\n\n\nfunction flatten(input) {\n  const {\n    indices\n  } = this;\n  const existing = indices.get(input);\n  if (existing) return [existing];\n  if (input === void 0) return UNDEFINED;\n  if (input === null) return NULL;\n  if (Number.isNaN(input)) return NAN;\n  if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\n\nfunction stringify(input, index) {\n  const {\n    deferred,\n    plugins,\n    postPlugins\n  } = this;\n  const str = this.stringified;\n  const stack = [[input, index]];\n\n  while (stack.length > 0) {\n    const [input2, index2] = stack.pop();\n\n    const partsForObj = obj => Object.keys(obj).map(k => `\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n\n    let error = null;\n\n    switch (typeof input2) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        str[index2] = JSON.stringify(input2);\n        break;\n\n      case \"bigint\":\n        str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n        break;\n\n      case \"symbol\":\n        {\n          const keyFor = Symbol.keyFor(input2);\n\n          if (!keyFor) {\n            error = new Error(\"Cannot encode symbol unless created with Symbol.for()\");\n          } else {\n            str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n          }\n\n          break;\n        }\n\n      case \"object\":\n        {\n          if (!input2) {\n            str[index2] = `${NULL}`;\n            break;\n          }\n\n          const isArray = Array.isArray(input2);\n          let pluginHandled = false;\n\n          if (!isArray && plugins) {\n            for (const plugin of plugins) {\n              const pluginResult = plugin(input2);\n\n              if (Array.isArray(pluginResult)) {\n                pluginHandled = true;\n                const [pluginIdentifier, ...rest] = pluginResult;\n                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n\n                if (rest.length > 0) {\n                  str[index2] += `,${rest.map(v => flatten.call(this, v)).join(\",\")}`;\n                }\n\n                str[index2] += \"]\";\n                break;\n              }\n            }\n          }\n\n          if (!pluginHandled) {\n            let result = isArray ? \"[\" : \"{\";\n\n            if (isArray) {\n              for (let i = 0; i < input2.length; i++) result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n\n              str[index2] = `${result}]`;\n            } else if (input2 instanceof Date) {\n              str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n            } else if (input2 instanceof URL) {\n              str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n            } else if (input2 instanceof RegExp) {\n              str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;\n            } else if (input2 instanceof Set) {\n              if (input2.size > 0) {\n                str[index2] = `[\"${TYPE_SET}\",${[...input2].map(val => flatten.call(this, val)).join(\",\")}]`;\n              } else {\n                str[index2] = `[\"${TYPE_SET}\"]`;\n              }\n            } else if (input2 instanceof Map) {\n              if (input2.size > 0) {\n                str[index2] = `[\"${TYPE_MAP}\",${[...input2].flatMap(_ref => {\n                  let [k, v] = _ref;\n                  return [flatten.call(this, k), flatten.call(this, v)];\n                }).join(\",\")}]`;\n              } else {\n                str[index2] = `[\"${TYPE_MAP}\"]`;\n              }\n            } else if (input2 instanceof Promise) {\n              str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n              deferred[index2] = input2;\n            } else if (input2 instanceof Error) {\n              str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n\n              if (input2.name !== \"Error\") {\n                str[index2] += `,${JSON.stringify(input2.name)}`;\n              }\n\n              str[index2] += \"]\";\n            } else if (Object.getPrototypeOf(input2) === null) {\n              str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n            } else if (isPlainObject(input2)) {\n              str[index2] = `{${partsForObj(input2)}}`;\n            } else {\n              error = new Error(\"Cannot encode object with prototype\");\n            }\n          }\n\n          break;\n        }\n\n      default:\n        {\n          const isArray = Array.isArray(input2);\n          let pluginHandled = false;\n\n          if (!isArray && plugins) {\n            for (const plugin of plugins) {\n              const pluginResult = plugin(input2);\n\n              if (Array.isArray(pluginResult)) {\n                pluginHandled = true;\n                const [pluginIdentifier, ...rest] = pluginResult;\n                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n\n                if (rest.length > 0) {\n                  str[index2] += `,${rest.map(v => flatten.call(this, v)).join(\",\")}`;\n                }\n\n                str[index2] += \"]\";\n                break;\n              }\n            }\n          }\n\n          if (!pluginHandled) {\n            error = new Error(\"Cannot encode function or unexpected type\");\n          }\n        }\n    }\n\n    if (error) {\n      let pluginHandled = false;\n\n      if (postPlugins) {\n        for (const plugin of postPlugins) {\n          const pluginResult = plugin(input2);\n\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n\n            if (rest.length > 0) {\n              str[index2] += `,${rest.map(v => flatten.call(this, v)).join(\",\")}`;\n            }\n\n            str[index2] += \"]\";\n            break;\n          }\n        }\n      }\n\n      if (!pluginHandled) {\n        throw error;\n      }\n    }\n  }\n}\n\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\n\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n} // src/unflatten.ts\n\n\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\n\nfunction unflatten(parsed) {\n  const {\n    hydrated,\n    values\n  } = this;\n  if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n  const startIndex = values.length;\n\n  for (const value of parsed) {\n    values.push(value);\n  }\n\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\n\nfunction hydrate(index) {\n  const {\n    hydrated,\n    values,\n    deferred,\n    plugins\n  } = this;\n  let result;\n  const stack = [[index, v => {\n    result = v;\n  }]];\n  let postRun = [];\n\n  while (stack.length > 0) {\n    const [index2, set] = stack.pop();\n\n    switch (index2) {\n      case UNDEFINED:\n        set(void 0);\n        continue;\n\n      case NULL:\n        set(null);\n        continue;\n\n      case NAN:\n        set(NaN);\n        continue;\n\n      case POSITIVE_INFINITY:\n        set(Infinity);\n        continue;\n\n      case NEGATIVE_INFINITY:\n        set(-Infinity);\n        continue;\n\n      case NEGATIVE_ZERO:\n        set(-0);\n        continue;\n    }\n\n    if (hydrated[index2]) {\n      set(hydrated[index2]);\n      continue;\n    }\n\n    const value = values[index2];\n\n    if (!value || typeof value !== \"object\") {\n      hydrated[index2] = value;\n      set(value);\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (typeof value[0] === \"string\") {\n        const [type, b, c] = value;\n\n        switch (type) {\n          case TYPE_DATE:\n            set(hydrated[index2] = new Date(b));\n            continue;\n\n          case TYPE_URL:\n            set(hydrated[index2] = new URL(b));\n            continue;\n\n          case TYPE_BIGINT:\n            set(hydrated[index2] = BigInt(b));\n            continue;\n\n          case TYPE_REGEXP:\n            set(hydrated[index2] = new RegExp(b, c));\n            continue;\n\n          case TYPE_SYMBOL:\n            set(hydrated[index2] = Symbol.for(b));\n            continue;\n\n          case TYPE_SET:\n            const newSet = /* @__PURE__ */new Set();\n            hydrated[index2] = newSet;\n\n            for (let i = 1; i < value.length; i++) stack.push([value[i], v => {\n              newSet.add(v);\n            }]);\n\n            set(newSet);\n            continue;\n\n          case TYPE_MAP:\n            const map = /* @__PURE__ */new Map();\n            hydrated[index2] = map;\n\n            for (let i = 1; i < value.length; i += 2) {\n              const r = [];\n              stack.push([value[i + 1], v => {\n                r[1] = v;\n              }]);\n              stack.push([value[i], k => {\n                r[0] = k;\n              }]);\n              postRun.push(() => {\n                map.set(r[0], r[1]);\n              });\n            }\n\n            set(map);\n            continue;\n\n          case TYPE_NULL_OBJECT:\n            const obj = /* @__PURE__ */Object.create(null);\n            hydrated[index2] = obj;\n\n            for (const key of Object.keys(b).reverse()) {\n              const r = [];\n              stack.push([b[key], v => {\n                r[1] = v;\n              }]);\n              stack.push([Number(key.slice(1)), k => {\n                r[0] = k;\n              }]);\n              postRun.push(() => {\n                obj[r[0]] = r[1];\n              });\n            }\n\n            set(obj);\n            continue;\n\n          case TYPE_PROMISE:\n            if (hydrated[b]) {\n              set(hydrated[index2] = hydrated[b]);\n            } else {\n              const d = new Deferred();\n              deferred[b] = d;\n              set(hydrated[index2] = d.promise);\n            }\n\n            continue;\n\n          case TYPE_ERROR:\n            const [, message, errorType] = value;\n            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n            hydrated[index2] = error;\n            set(error);\n            continue;\n\n          case TYPE_PREVIOUS_RESOLVED:\n            set(hydrated[index2] = hydrated[b]);\n            continue;\n\n          default:\n            if (Array.isArray(plugins)) {\n              const r = [];\n              const vals = value.slice(1);\n\n              for (let i = 0; i < vals.length; i++) {\n                const v = vals[i];\n                stack.push([v, v2 => {\n                  r[i] = v2;\n                }]);\n              }\n\n              postRun.push(() => {\n                for (const plugin of plugins) {\n                  const result2 = plugin(value[0], ...r);\n\n                  if (result2) {\n                    set(hydrated[index2] = result2.value);\n                    return;\n                  }\n                }\n\n                throw new SyntaxError();\n              });\n              continue;\n            }\n\n            throw new SyntaxError();\n        }\n      } else {\n        const array = [];\n        hydrated[index2] = array;\n\n        for (let i = 0; i < value.length; i++) {\n          const n = value[i];\n\n          if (n !== HOLE) {\n            stack.push([n, v => {\n              array[i] = v;\n            }]);\n          }\n        }\n\n        set(array);\n        continue;\n      }\n    } else {\n      const object = {};\n      hydrated[index2] = object;\n\n      for (const key of Object.keys(value).reverse()) {\n        const r = [];\n        stack.push([value[key], v => {\n          r[1] = v;\n        }]);\n        stack.push([Number(key.slice(1)), k => {\n          r[0] = k;\n        }]);\n        postRun.push(() => {\n          object[r[0]] = r[1];\n        });\n      }\n\n      set(object);\n      continue;\n    }\n  }\n\n  while (postRun.length > 0) {\n    postRun.pop()();\n  }\n\n  return result;\n} // src/turbo-stream.ts\n\n\nasync function decode(readable, options) {\n  const {\n    plugins\n  } = options ?? {};\n  const done = new Deferred();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch(reason => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n\n      done.reject(reason);\n    });\n  }\n\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\n\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n\n  let line;\n\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\n\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n\n  while (!read.done) {\n    if (!read.value) continue;\n    const line = read.value;\n\n    switch (line[0]) {\n      case TYPE_PROMISE:\n        {\n          const colonIndex = line.indexOf(\":\");\n          const deferredId = Number(line.slice(1, colonIndex));\n          const deferred = this.deferred[deferredId];\n\n          if (!deferred) {\n            throw new Error(`Deferred ID ${deferredId} not found in stream`);\n          }\n\n          const lineData = line.slice(colonIndex + 1);\n          let jsonLine;\n\n          try {\n            jsonLine = JSON.parse(lineData);\n          } catch (reason) {\n            throw new SyntaxError();\n          }\n\n          const value = unflatten.call(this, jsonLine);\n          deferred.resolve(value);\n          break;\n        }\n\n      case TYPE_ERROR:\n        {\n          const colonIndex = line.indexOf(\":\");\n          const deferredId = Number(line.slice(1, colonIndex));\n          const deferred = this.deferred[deferredId];\n\n          if (!deferred) {\n            throw new Error(`Deferred ID ${deferredId} not found in stream`);\n          }\n\n          const lineData = line.slice(colonIndex + 1);\n          let jsonLine;\n\n          try {\n            jsonLine = JSON.parse(lineData);\n          } catch (reason) {\n            throw new SyntaxError();\n          }\n\n          const value = unflatten.call(this, jsonLine);\n          deferred.reject(value);\n          break;\n        }\n\n      default:\n        throw new SyntaxError();\n    }\n\n    read = await reader.read();\n  }\n}\n\nfunction encode(input, options) {\n  const {\n    plugins,\n    postPlugins,\n    signal\n  } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */new Map(),\n    stringified: [],\n    plugins,\n    postPlugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`));\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n\n      const seenPromises = /* @__PURE__ */new WeakSet();\n\n      while (Object.keys(encoder.deferred).length > 0) {\n        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {\n          if (seenPromises.has(deferred)) continue;\n          seenPromises.add(encoder.deferred[Number(deferredId)] = raceSignal(deferred, encoder.signal).then(resolved => {\n            const id2 = flatten.call(encoder, resolved);\n\n            if (Array.isArray(id2)) {\n              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n              encoder.index++;\n              lastSentIndex++;\n            } else if (id2 < 0) {\n              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`));\n            } else {\n              const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]\n`));\n              lastSentIndex = encoder.stringified.length - 1;\n            }\n          }, reason => {\n            if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n              reason = new Error(\"An unknown error occurred\");\n            }\n\n            const id2 = flatten.call(encoder, reason);\n\n            if (Array.isArray(id2)) {\n              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n              encoder.index++;\n              lastSentIndex++;\n            } else if (id2 < 0) {\n              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`));\n            } else {\n              const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]\n`));\n              lastSentIndex = encoder.stringified.length - 1;\n            }\n          }).finally(() => {\n            delete encoder.deferred[Number(deferredId)];\n          }));\n        }\n\n        await Promise.race(Object.values(encoder.deferred));\n      }\n\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n\n  });\n  return readable;\n}\n\nfunction raceSignal(promise, signal) {\n  if (!signal) return promise;\n  if (signal.aborted) return Promise.reject(signal.reason || new Error(\"Signal was aborted.\"));\n  const abort = new Promise((resolve, reject) => {\n    signal.addEventListener(\"abort\", event => {\n      reject(signal.reason || new Error(\"Signal was aborted.\"));\n    });\n    promise.then(resolve).catch(reject);\n  });\n  abort.catch(() => {});\n  return Promise.race([abort, promise]);\n}\n\nexport { decode, encode };","map":{"version":3,"sources":["C:/Users/Oscar/Documents/parqueadero-react/parqueadero-react/node_modules/turbo-stream/dist/turbo-stream.mjs"],"names":["HOLE","NAN","NEGATIVE_INFINITY","NEGATIVE_ZERO","NULL","POSITIVE_INFINITY","UNDEFINED","TYPE_BIGINT","TYPE_DATE","TYPE_ERROR","TYPE_MAP","TYPE_NULL_OBJECT","TYPE_PROMISE","TYPE_REGEXP","TYPE_SET","TYPE_SYMBOL","TYPE_URL","TYPE_PREVIOUS_RESOLVED","Deferred","promise","resolve","reject","constructor","Promise","createLineSplittingTransform","decoder","TextDecoder","leftover","TransformStream","transform","chunk","controller","str","decode","stream","parts","split","pop","part","enqueue","flush","flatten","input","indices","existing","get","Number","isNaN","index","set","stringify","call","deferred","plugins","postPlugins","stringified","stack","length","input2","index2","partsForObj","obj","Object","keys","map","k","join","error","JSON","keyFor","Symbol","Error","isArray","Array","pluginHandled","plugin","pluginResult","pluginIdentifier","rest","v","result","i","Date","getTime","URL","href","RegExp","source","flags","Set","size","val","Map","flatMap","message","name","getPrototypeOf","isPlainObject","objectProtoNames","getOwnPropertyNames","prototype","sort","thing","proto","globalObj","window","globalThis","unflatten","parsed","hydrated","values","hydrate","SyntaxError","startIndex","value","push","postRun","NaN","Infinity","type","b","c","BigInt","for","newSet","add","r","create","key","reverse","slice","d","errorType","vals","v2","result2","array","n","object","readable","options","done","reader","pipeThrough","getReader","decoded","decodeInitial","donePromise","decodeDeferred","then","catch","reason","closed","read","line","parse","colonIndex","indexOf","deferredId","lineData","jsonLine","encode","signal","encoder","textEncoder","TextEncoder","lastSentIndex","ReadableStream","start","id","seenPromises","WeakSet","entries","has","raceSignal","resolved","id2","finally","race","all","close","aborted","abort","addEventListener","event"],"mappings":"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","sourcesContent":["// src/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred = class {\n  promise;\n  resolve;\n  reject;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n};\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, { stream: true });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n  });\n}\n\n// src/flatten.ts\nfunction flatten(input) {\n  const { indices } = this;\n  const existing = indices.get(input);\n  if (existing)\n    return [existing];\n  if (input === void 0)\n    return UNDEFINED;\n  if (input === null)\n    return NULL;\n  if (Number.isNaN(input))\n    return NAN;\n  if (input === Number.POSITIVE_INFINITY)\n    return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY)\n    return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0)\n    return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\nfunction stringify(input, index) {\n  const { deferred, plugins, postPlugins } = this;\n  const str = this.stringified;\n  const stack = [[input, index]];\n  while (stack.length > 0) {\n    const [input2, index2] = stack.pop();\n    const partsForObj = (obj) => Object.keys(obj).map((k) => `\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n    let error = null;\n    switch (typeof input2) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        str[index2] = JSON.stringify(input2);\n        break;\n      case \"bigint\":\n        str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n        break;\n      case \"symbol\": {\n        const keyFor = Symbol.keyFor(input2);\n        if (!keyFor) {\n          error = new Error(\n            \"Cannot encode symbol unless created with Symbol.for()\"\n          );\n        } else {\n          str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n        }\n        break;\n      }\n      case \"object\": {\n        if (!input2) {\n          str[index2] = `${NULL}`;\n          break;\n        }\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          let result = isArray ? \"[\" : \"{\";\n          if (isArray) {\n            for (let i = 0; i < input2.length; i++)\n              result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n            str[index2] = `${result}]`;\n          } else if (input2 instanceof Date) {\n            str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n          } else if (input2 instanceof URL) {\n            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n          } else if (input2 instanceof RegExp) {\n            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(\n              input2.source\n            )},${JSON.stringify(input2.flags)}]`;\n          } else if (input2 instanceof Set) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_SET}\",${[...input2].map((val) => flatten.call(this, val)).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_SET}\"]`;\n            }\n          } else if (input2 instanceof Map) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_MAP}\",${[...input2].flatMap(([k, v]) => [\n                flatten.call(this, k),\n                flatten.call(this, v)\n              ]).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_MAP}\"]`;\n            }\n          } else if (input2 instanceof Promise) {\n            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n            deferred[index2] = input2;\n          } else if (input2 instanceof Error) {\n            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n            if (input2.name !== \"Error\") {\n              str[index2] += `,${JSON.stringify(input2.name)}`;\n            }\n            str[index2] += \"]\";\n          } else if (Object.getPrototypeOf(input2) === null) {\n            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n          } else if (isPlainObject(input2)) {\n            str[index2] = `{${partsForObj(input2)}}`;\n          } else {\n            error = new Error(\"Cannot encode object with prototype\");\n          }\n        }\n        break;\n      }\n      default: {\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          error = new Error(\"Cannot encode function or unexpected type\");\n        }\n      }\n    }\n    if (error) {\n      let pluginHandled = false;\n      if (postPlugins) {\n        for (const plugin of postPlugins) {\n          const pluginResult = plugin(input2);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index2] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        throw error;\n      }\n    }\n  }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n}\n\n// src/unflatten.ts\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n  const { hydrated, values } = this;\n  if (typeof parsed === \"number\")\n    return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length)\n    throw new SyntaxError();\n  const startIndex = values.length;\n  for (const value of parsed) {\n    values.push(value);\n  }\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n  const { hydrated, values, deferred, plugins } = this;\n  let result;\n  const stack = [\n    [\n      index,\n      (v) => {\n        result = v;\n      }\n    ]\n  ];\n  let postRun = [];\n  while (stack.length > 0) {\n    const [index2, set] = stack.pop();\n    switch (index2) {\n      case UNDEFINED:\n        set(void 0);\n        continue;\n      case NULL:\n        set(null);\n        continue;\n      case NAN:\n        set(NaN);\n        continue;\n      case POSITIVE_INFINITY:\n        set(Infinity);\n        continue;\n      case NEGATIVE_INFINITY:\n        set(-Infinity);\n        continue;\n      case NEGATIVE_ZERO:\n        set(-0);\n        continue;\n    }\n    if (hydrated[index2]) {\n      set(hydrated[index2]);\n      continue;\n    }\n    const value = values[index2];\n    if (!value || typeof value !== \"object\") {\n      hydrated[index2] = value;\n      set(value);\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (typeof value[0] === \"string\") {\n        const [type, b, c] = value;\n        switch (type) {\n          case TYPE_DATE:\n            set(hydrated[index2] = new Date(b));\n            continue;\n          case TYPE_URL:\n            set(hydrated[index2] = new URL(b));\n            continue;\n          case TYPE_BIGINT:\n            set(hydrated[index2] = BigInt(b));\n            continue;\n          case TYPE_REGEXP:\n            set(hydrated[index2] = new RegExp(b, c));\n            continue;\n          case TYPE_SYMBOL:\n            set(hydrated[index2] = Symbol.for(b));\n            continue;\n          case TYPE_SET:\n            const newSet = /* @__PURE__ */ new Set();\n            hydrated[index2] = newSet;\n            for (let i = 1; i < value.length; i++)\n              stack.push([\n                value[i],\n                (v) => {\n                  newSet.add(v);\n                }\n              ]);\n            set(newSet);\n            continue;\n          case TYPE_MAP:\n            const map = /* @__PURE__ */ new Map();\n            hydrated[index2] = map;\n            for (let i = 1; i < value.length; i += 2) {\n              const r = [];\n              stack.push([\n                value[i + 1],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                value[i],\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                map.set(r[0], r[1]);\n              });\n            }\n            set(map);\n            continue;\n          case TYPE_NULL_OBJECT:\n            const obj = /* @__PURE__ */ Object.create(null);\n            hydrated[index2] = obj;\n            for (const key of Object.keys(b).reverse()) {\n              const r = [];\n              stack.push([\n                b[key],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                Number(key.slice(1)),\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                obj[r[0]] = r[1];\n              });\n            }\n            set(obj);\n            continue;\n          case TYPE_PROMISE:\n            if (hydrated[b]) {\n              set(hydrated[index2] = hydrated[b]);\n            } else {\n              const d = new Deferred();\n              deferred[b] = d;\n              set(hydrated[index2] = d.promise);\n            }\n            continue;\n          case TYPE_ERROR:\n            const [, message, errorType] = value;\n            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n            hydrated[index2] = error;\n            set(error);\n            continue;\n          case TYPE_PREVIOUS_RESOLVED:\n            set(hydrated[index2] = hydrated[b]);\n            continue;\n          default:\n            if (Array.isArray(plugins)) {\n              const r = [];\n              const vals = value.slice(1);\n              for (let i = 0; i < vals.length; i++) {\n                const v = vals[i];\n                stack.push([\n                  v,\n                  (v2) => {\n                    r[i] = v2;\n                  }\n                ]);\n              }\n              postRun.push(() => {\n                for (const plugin of plugins) {\n                  const result2 = plugin(value[0], ...r);\n                  if (result2) {\n                    set(hydrated[index2] = result2.value);\n                    return;\n                  }\n                }\n                throw new SyntaxError();\n              });\n              continue;\n            }\n            throw new SyntaxError();\n        }\n      } else {\n        const array = [];\n        hydrated[index2] = array;\n        for (let i = 0; i < value.length; i++) {\n          const n = value[i];\n          if (n !== HOLE) {\n            stack.push([\n              n,\n              (v) => {\n                array[i] = v;\n              }\n            ]);\n          }\n        }\n        set(array);\n        continue;\n      }\n    } else {\n      const object = {};\n      hydrated[index2] = object;\n      for (const key of Object.keys(value).reverse()) {\n        const r = [];\n        stack.push([\n          value[key],\n          (v) => {\n            r[1] = v;\n          }\n        ]);\n        stack.push([\n          Number(key.slice(1)),\n          (k) => {\n            r[0] = k;\n          }\n        ]);\n        postRun.push(() => {\n          object[r[0]] = r[1];\n        });\n      }\n      set(object);\n      continue;\n    }\n  }\n  while (postRun.length > 0) {\n    postRun.pop()();\n  }\n  return result;\n}\n\n// src/turbo-stream.ts\nasync function decode(readable, options) {\n  const { plugins } = options ?? {};\n  const done = new Deferred();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n      done.reject(reason);\n    });\n  }\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n  let line;\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n  while (!read.done) {\n    if (!read.value)\n      continue;\n    const line = read.value;\n    switch (line[0]) {\n      case TYPE_PROMISE: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.resolve(value);\n        break;\n      }\n      case TYPE_ERROR: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.reject(value);\n        break;\n      }\n      default:\n        throw new SyntaxError();\n    }\n    read = await reader.read();\n  }\n}\nfunction encode(input, options) {\n  const { plugins, postPlugins, signal } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */ new Map(),\n    stringified: [],\n    plugins,\n    postPlugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(\n          textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`)\n        );\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n      const seenPromises = /* @__PURE__ */ new WeakSet();\n      while (Object.keys(encoder.deferred).length > 0) {\n        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {\n          if (seenPromises.has(deferred))\n            continue;\n          seenPromises.add(\n            encoder.deferred[Number(deferredId)] = raceSignal(\n              deferred,\n              encoder.signal\n            ).then(\n              (resolved) => {\n                const id2 = flatten.call(encoder, resolved);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                  encoder.index++;\n                  lastSentIndex++;\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              },\n              (reason) => {\n                if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                  reason = new Error(\"An unknown error occurred\");\n                }\n                const id2 = flatten.call(encoder, reason);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                  encoder.index++;\n                  lastSentIndex++;\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              }\n            ).finally(() => {\n              delete encoder.deferred[Number(deferredId)];\n            })\n          );\n        }\n        await Promise.race(Object.values(encoder.deferred));\n      }\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n  });\n  return readable;\n}\nfunction raceSignal(promise, signal) {\n  if (!signal)\n    return promise;\n  if (signal.aborted)\n    return Promise.reject(signal.reason || new Error(\"Signal was aborted.\"));\n  const abort = new Promise((resolve, reject) => {\n    signal.addEventListener(\"abort\", (event) => {\n      reject(signal.reason || new Error(\"Signal was aborted.\"));\n    });\n    promise.then(resolve).catch(reject);\n  });\n  abort.catch(() => {\n  });\n  return Promise.race([abort, promise]);\n}\nexport {\n  decode,\n  encode\n};\n"]},"metadata":{},"sourceType":"module"}